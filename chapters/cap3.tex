\chapter{Realizzazione dell'applicazione}
\label{cap:realizzazione_applicazione}
Il presente capitolo descrive la realizzazione dell'applicazione \textit{Key Wallet App} illustrando in primo luogo la fase di pianificazione e di analisi per poi proseguire verso i problemi riscontrati durante lo sviluppo, la loro mitigazione e le scelte che sono state compiute. Si conclude con un resoconto su quanto è stato realizzato.
\section{Pianificazione del lavoro}
Come introdotto nel capitolo 2, l’obiettivo del mio progetto era una valutazione di fattibilità e di potenziale impiego di nuove tecnologie per l’azienda in prodotti nuovi. Pertanto ho dovuto coniugare rigidità nella fase di studio e flessibilità nella fase di sviluppo e implementazione. Quindi per la realizzazione del progetto ho scelto un approccio ibrido tra un modello sequenziale a cascata durante lo studio e la pianificazione, e un modello agile per la realizzazione dell'applicazione.

\begin{table}[H]
    \centering
    \begin{tabular}{|p{6cm}|c|c|c|c|c|c|c|c|c|}
        \hline
        \textbf{Attività} & \multicolumn{8}{|c|}{\textbf{Settimane}} & \textbf{Ore} \\
        \hline
         & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & \\
        \hline
        Ripasso costrutti di Java & X & & & & & & & & 5 \\
        \hline
        Studio di Dart & X & X & & & & & & & 30 \\
        \hline
        Studio di Flutter & & X & X & & & & & & 40 \\
        \hline
        Studio algoritmi di criptazione &  & X & & X & & X & & & 30 \\
        \hline
        Analisi del problema & X &  & &  & & & & & 10 \\
        \hline
        Progettazione della piattaforma &  &  &  & X & & & & & 25 \\
        \hline
        Sviluppo maschera di \textit{login} &  &  & X & & & & & & 5 \\
        \hline
        Sviluppo di un prototipo che genera chiavi &  &  & X & & & & & & 30 \\
        \hline
        Sviluppo applicazione finale &  &  & & & X & X & X & & 100 \\
        \hline
        Stesura finale della specifica tecnica &  &  & & &  & & X & X & 20 \\
        \hline
        \textit{Live demo} e presentazione finale &  &  & & & & & & X & 5 \\
        \hline
        \textbf{totale ore} & \multicolumn{9}{|c|}{300}\\
        \hline
    \end{tabular}
    \caption{Pianificazione del lavoro durante le 8 settimane}
\end{table}

Durante le prime settimane di \textit{stage}, ho applicato una metodologia a cascata, essenziale per stabilire le fondamenta del progetto. Nel primo blocco ho lavorato a stretto contatto con il mio responsabile per definire gli obiettivi e la struttura del progetto. Dopodiché mi sono concentrato sullo studio del linguaggio Dart e del framework Flutter, per poi spostarmi sulla libreria di \texttt{pointycastle} e sugli gli algoritmi di crittografia. Dalla terza settimana fino alla quarta mi sono concentrato sullo sviluppo di piccoli prototipi, per esempio: \textit{login} finto, generazione di chiavi alla pressione di un tasto e lettura di \textit{tag} NFC.
 Questi sono stati molto utili per effettuare \textit{test} sulle funzioni nelle settimane successive e a trovare immediatamente falle all'interno del progetto. Una fra tutte la lettura di \textit{tag} NFC, i quali
 non possiedono un identificativo fisso sulle carte d’identità elettroniche.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{../assets/modelloCascata.png} 
    \caption{Modello a cascata - Fonte: programmingacademy.it}
\end{figure}

Una volta completata la prototipazione, il progetto è transitato verso una metodologia agile, in particolare durante la realizzazione dell’applicazione finale.
 Lo sviluppo agile offre una gestione flessibile dei problemi tecnici e la possibilità di concentrarsi in modo progressivo sull’implementazione dei singoli componenti del sistema, permettendo di integrare funzionalità ad ogni iterazione.
  Questo significa che per le ultime fasi del progetto pianificavo, sviluppavo e testavo le funzionalità implementate, reagendo immediatamente ai problemi riscontrati, uno tra questi, l’uso di un algoritmo RSA senza \textit{padding}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{../assets/agile.png} 
    \caption{Modello agile - Fonte: smartsheet.com}
\end{figure}

In definitiva, l’adozione dell’approccio ibrido ha garantito la copertura formativa e analitica iniziale, consentendo al contempo la gestione flessibile e sicura delle complessità tecniche emerse durante lo sviluppo.


\section{Analisi dei requisiti}
La fase di analisi svolta durante le prime settimane del percorso di \textit{stage},
 è stata cruciale per definire l’architettura applicativa e le tecnologie da utilizzare.
  Gli incontri con il \textit{tutor} hanno rappresentato un fulcro importante per lo sviluppo e la definizione del progetto.
   Le diverse iterazioni hanno permesso di delineare le linee guida e velocizzare le scelte tecnologiche, ad esempio l’uso di librerie specifiche come \texttt{pointycastle} per la crittografia o \texttt{flutter\_secure\_storage} per la gestione locale della chiave privata.
    A seguito di queste indicazioni durante la fase di analisi mi sono focalizzato sullo studio di fattibilità delle tecnologie e sullo sviluppo di prototipi. 


\subsection{Requisiti funzionali}
I requisiti funzionali definiscono le funzionalità e i servizi specifici che l’applicazione deve fornire per conseguire gli obiettivi del progetto.
Ogni requisito funzionale è codificato in questo modo: \textbf{RF[Numero]}.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|p{10cm}|}
        \hline
        \textbf{Codice} & \textbf{Descrizione} \\
        \hline
        \textbf{RF1} & Generazione di una coppia di chiavi pubbliche e private\\
        \hline
        \textbf{RF2} & Generazione ed eliminazione di \textit{wallet} contenenti le coppie di chiavi\\
        \hline
        \textbf{RF3} & Implementazione della parte di accesso e registrazione tramite appoggio di \textit{database}\\
        \hline
        \textbf{RF4} & Implementazione di un meccanismo di storage sicuro che permetta agli utenti di salvare le chiavi private sul \textit{Keystore/Keychain} del dispositivo\\
        \hline
        \textbf{RF5} & Riuscire a criptare un messaggio inserito nell'applicazione tramite la chiave pubblica di un altro utente\\
        \hline
        \textbf{RF6} & Riuscire a decifrare un messaggio tramite la propria chiave privata personale\\
        \hline
        \textbf{RF7} & Implementazione di un meccanismo di recupero \textit{wallet} \\
        \hline
        \textbf{RF8} & Implementazione di un meccanismo di lettura di \textit{tag NFC} per associare un documento a un \textit{wallet}\\
        \hline
    \end{tabular}
    \caption{Requisiti funzionali}
\end{table}

\subsection{Requisiti di qualità}
I requisiti di qualità stabiliscono gli \textit{standard} secondo i quali le funzionalità del prodotto devono essere realizzate ed eseguite, assicurando un elevato livello di affidabilità e coerenza del sistema.
Sono stati definiti all’inizio del percorso di \textit{stage} e hanno costituito i criteri finali per la valutazione del progetto.
Ogni requisito di qualità è codificato in questo modo: \textbf{RQ[Numero]}.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|p{10cm}|}
        \hline
        \textbf{Codice} & \textbf{Descrizione} \\
        \hline
        \textbf{RQ1} & Assicurare un'accuratezza nella generazione e crittografia delle chiavi superiore al 95\% \\
        \hline
        \textbf{RQ2} & Mantenere il tempo di risposta per la generazione del \textit{wallet} al di sotto dei 2 secondi\\
        \hline
        \textbf{RQ3} & Raggiungere una copertura di test automatici del 70\% per le principali funzionalità\\
        \hline
    \end{tabular}
    \caption{Requisiti di qualità}
\end{table}

Ognuno di questi requisiti è stato verificato attraverso lo sviluppo di test automatici.


\subsection{Requisiti di vincolo}
I requisiti di vincolo definiscono le limitazioni operative e tecnologiche cui il progetto ha dovuto attenersi,
 influenzano direttamente le scelte architetturali e l'ambito di sviluppo. 
Abbiamo già discusso dei vincoli del progetto nella sezione 2.4.2. Pertanto mi limito a elencarli in questa sezione.
Ogni requisito di vincolo è codificato in questo modo: \textbf{RV[Numero]}.

\begin{table}[H]
    \centering
    \begin{tabular}{|c|p{10cm}|}
        \hline
        \textbf{Codice} & \textbf{Descrizione} \\
        \hline
        \textbf{RV1} & L'applicazione finale deve essere sviluppata tramite il \textit{framework} Flutter e il linguaggio Dart\\
        \hline
        \textbf{RV2} & L'applicazione finale deve appoggiarsi a Firebase come appoggio per una base di dati \\
        \hline
        \textbf{RV3} & Le chiavi private generate non devono essere trasmesse \textit{online} ma devono essere cutodite in spazi sicuri del dispositivo come il \textit{Keychain} e \textit{Keystore}\\
        \hline
        \textbf{RV4} & Ogni documento deve essere associato a unico wallet\\
        \hline
    \end{tabular}
    \caption{Requisiti di vincolo}
\end{table}


\section{Implementazione}
\subsection{Il linguaggio Dart}
Lo studio di questo linguaggio di programmazione ha rappresentato la prima sfida del progetto,
 in quanto rappresenta la base da cui partire per costruire l’intera applicazione.
Nonostante non avessi mai visto né provato questo linguaggio, 
 la sua sintassi simile a Java e JavaScript hanno fortemente semplificato il suo apprendimento. Riporto di seguito le principali differenze e peculiarità che ritengo importante sottolineare,
  in quanto caratteristiche fondamentali del linguaggio:
\subsubsection*{Utilizzo}
Dart è un linguaggio di programmazione orientato agli oggetti sviluppato da Google,
 è stato concepito come alternativa a JavaScript per lo sviluppo \textit{web}.
  Sebbene non abbia trovato ampia adozione in questo settore,
   Dart si è affermato come linguaggio versatile ed efficace nello sviluppo di applicazioni multipiattaforma.
    Una delle sue caratteristiche è quella di essere compilato verso diversi \textit{target}:
     ARM64 per i dispositivi mobili, JavaScript per il \textit{web}, e architetture x86\_64 per i sistemi operativi \textit{desktop} quali Windows, macOS e Linux. 
\subsubsection*{\textit{Type-safe}}
Dart è un linguaggio \textit{type-safe}: ovvero ogni variabile mantiene una corrispondenza certa con il proprio tipo statico. Però allo stesso tempo offre un sistema di tipizzazione flessibile grazie alla \textit{keyword} \texttt{dynamic}, che permette la verifica dei tipi a \textit{run-time} quando necessario.

\begin{listing}[H]
\caption{Esempio di \textit{type-safe}}
\begin{minted}{dart}
void main() {
  int temp = 10;
  temp = 20; // OK
  //temp = "ciao"; // ILLEGALE: string != int

  print(temp); // stampa 20
  
  dynamic temp1 = 30;
  print(temp1); // stampa 30
  temp1 = "ciao";
  print(temp1); // stampa ciao
}
\end{minted}
\end{listing}

\subsubsection*{\textit{null-safe}}
Il linguaggio integra un sistema di \textit{null safety}:
 il valore \texttt{null} può essere associato a una variabile solo se esplicitamente dichiarato.

\begin{listing}[H]
\caption{Esempio di \textit{null safety}}
\begin{minted}{dart}
void main() {
  String nome = "Mario";
  print(nome); // stampa: Mario
  //nome = null; //ILLEGALE: null non può essere assegnato a String

  String? cognome = "Rossi";
  cognome = null;
  print(cognome); //Nessun problema stampa null
}

\end{minted}
\end{listing}

\newpage

\subsubsection*{Interfacce e classi astratte}
In Dart sia le interfacce esplicite che le classi astratte sono dichiarate usando la \textit{keyword} \texttt{abstract class}.
La distinzione dei due concetti risiede nel modo in cui vengono utilizzate le classi derivate:
\begin{itemize}
  \item Un’interfaccia definisce un contratto: qualsiasi classe che la derivi deve utilizzare la \textit{keyword} \texttt{implements}, impegnandosi pertanto a fornire una implementazione concreta di tutti i metodi dichiarati.
  \item Una classe astratta può essere estesa tramite la \textit{keyword} \texttt{extends} e può contenere sia i metodi astratti sia metodi già implementati. 
\end{itemize}

\begin{listing}[H]
\caption{Esempio di interfaccia e classe astratta}
\begin{minted}{dart}
abstract class ContrattoDiConnessione { 
  void connetti();
  void disconetti();
}

class B{
    void bMethod() {}
}

abstract class BaseScreen {
  void logicaComune() {}
}

class GestoreServizio implements ContrattoDiConnessione, B {
  @override
  void connetti() { /* implementazione */ }
  @override
  void disconetti() { /* implementazione */ }
  @override
  void bMethod() {/* implementazione */}
}

class HomePage extends BaseScreen { 
  void init() {
    super.logicaComune();
  }
}
\end{minted}
\end{listing}
In Dart, ogni classe definita genera implicitamente una interfaccia che include tutti i suoi metodi e proprietà pubbliche.

\newpage

\subsection{Il \textit{framework} Flutter}

La seconda sfida è stata lo studio del \textit{framework} Flutter. Flutter non utilizza componenti di interfaccia nativi del sistema operativo ospite,
 ma al contrario sfrutta un suo motore grafico che disegna direttamente sulla schermata del dispositivo,
  garantendo un controllo totale sul \textit{rendering} dell’interfaccia e prestazioni comparabili
   a quelle delle applicazioni native. 
Sfruttando il linguaggio Dart, Flutter supporta funzioni specifiche che permettono al programmatore di velocizzare lo sviluppo. Una di queste funzioni è l'\textit{hot-reload} che permette di visualizzare immediatamente le modifiche al codice senza dover aspettare ogni volta una nuova compilazione.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.57\textwidth]{../assets/flutterWidgets.png} 
    \caption{Composizione dei \textit{widget} - Fonte: docs.flutter.dev}
\end{figure}

Per lavorare bene in Flutter è fondamentale comprendere che ogni elemento dell’interfaccia è rappresentato da un \textit{widget}.
 Il \textit{framework} adotta un approccio basato sulla composizione, tutto dagli elementi più semplici ai \textit{layout} più complessi è costruito tramite \textit{widget} annidati tra loro.
  Per fare un esempio banale, una schermata tipica in Flutter è definita attraverso il \textit{widget} \texttt{Scaffold} che fornisce la struttura di base dell’interfaccia.
   Lo \texttt{Scaffold} accetta parametri come \texttt{appBar}, \texttt{body} e \texttt{floatingActionButton}. Questi parametri verranno a loro volta definiti tramite altri \textit{widget}. Bisogna tuttavia fare una distinzione importante tra i \textit{widget} senza stato \textit{(stateless)} e i \textit{widget} con stato \textit{(stateful)}.

   \subsubsection*{\textit{Stateless widget}}
Uno \textit{stateless widget} è un \textit{widget} immutabile, ovvero un componente la cui configurazione non cambia durante l’intero ciclo di vita.

\begin{listing}[H]
\caption{\textit{Stateless Widget}}
\begin{minted}{dart}
class Titolo extends StatelessWidget {
  final String testo;

  const Titolo({super.key, required this.testo});

  @override
  Widget build(BuildContext context) {
    return Text(testo);
  }
}

\end{minted}
\end{listing}

\subsubsection*{\textit{Stateful widget}}
Uno \textit{stateful widget} è un \textit{widget} mutabile, in grado di mantenere e aggiornare un suo stato interno. Questo stato è gestito da una classe chiamata \texttt{State} che  permette di modificare lo stato e aggiornare l’interfaccia. Quando lo stato cambia, Flutter chiama il metodo \texttt{setState()}, che a sua volta forza la ricostruzione del \textit{widget}.

\begin{listing}[H]
  \caption{\textit{Stateful Widget}}
  \begin{minted}{dart}
class Contatore extends StatefulWidget {
  const Contatore({super.key});

  @override
  State<Contatore> createState() => _ContatoreState();
}

class _ContatoreState extends State<Contatore> {
  int valore = 0;

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Valore: $valore'),
        ElevatedButton(
          onPressed: () {
            setState(() {
              valore++;
            });
          },
          child: Text('Incrementa'),
        ),
      ],
    );
  }
}

  \end{minted}
\end{listing}

\newpage

\subsection{Architettura a tre livelli}
L’applicazione sviluppata adotta il modello di architettura a tre livelli, una struttura che segmenta i componenti \textit{software} in strati logicamente distinti, ciascuno con responsabilità differenti e ben definite.

\begin{itemize}
  \item Il primo livello di presentazione rappresenta un punto di interazione tra l’utente e il sistema. È composto da tutto ciò che definisce l’interfaccia grafica, quindi le schermate e \textit{widget} che le compongono. La sua funzione è quella di presentare i dati in chiaro e raccogliere l’\textit{input} dell’utente.
  \item Il secondo livello rappresenta la logica di \textit{business}: coordina le operazioni tra il livello di presentazione e il livello dei dati. Nel mio caso specifico è responsabile di operazioni fondamentali come la generazione delle chiavi crittografiche e l’esecuzione dei processi di cifratura e decifratura.
  \item Il terzo livello è responsabile della persistenza e recupero dei dati. Definisce come questi vengono archiviati e resi disponibili agli altri livelli.
\end{itemize}

\subsection{Il \textit{design pattern provider}}
Per gestire lo stato dei \textit{widget} nell’applicazione realizzata è stato adottato il \textit{design pattern provider}
 poiché si allinea perfettamente alle esigenze di una architettura a tre livelli in quanto:
\begin{enumerate}
  \item Permette la separazione delle responsabilità (SoC\footnote{Separation of Concerns è un principio di progettazione che suddivide un sistema in moduli distinti, ciascuno responsabile di una specifica funzione.}) eliminando la necessità di propagare le informazioni tramite la gerarchia dei \textit{widget}.
  \item Aumenta le \textit{performance} consentendoci di costruire i \textit{widget} strettamente necessari quando lo stato cambia, evitando i \textit{rebuild} di intere porzioni dell’interfaccia.
  \item Fornisce un meccanismo per accedere e aggiornare lo stato rendendo il codice più facile da mantenere, facilitando quindi l’introduzione di funzionalità o la modifica di quelle esistenti.
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{../assets/providerPattern.png} 
    \caption{Architettura a tre livelli}
\end{figure}


\subsection{la tecnologia NFC}
La tecnologia NFC permette a due dispositivi di connettersi, 
scambiarsi informazioni o attivare funzioni nel momento in cui si trovano a una distanza ravvicinata.
 Depositato da Charles Walton nel 1983, NFC nasce nel 2002 grazie all’intenzione di Sony e Philips
  di cooperare nella creazione di uno \textit{standard} per la comunicazione a radiofrequenza
   e L’ISO\footnote{International Standard Organization è un organismo internazionale che sviluppa e pubblica standard volontari coprendo una vasta gamma di settori} lo approva come \textit{standard} solo nel 2003.
    L’idea è quella di integrare informazioni all’interno dei dispositivi mobili tramite una semplice iterazione tra documenti e telefoni. 

\subsubsection{Lettura dati nei \textit{chip} RFID}
Uno dei requisiti era l’implementazione di un meccanismo di riconoscimento dei documenti contenenti
 il \textit{chip} RFID per associare le coppie di chiavi al ID del documento.
  In buona sostanza alla creazione del \textit{wallet} l'utente avrebbe dovuto scansionare un documento.
\newline
\newline
Per realizzare ciò ho analizzato due librerie Flutter che permettono la scansione 
e la scrittura attivando il sensore NFC presente sul telefono. La prima \texttt{nfc\_manager} alla versione 4.1.1 
è stata scartata in quanto da poco tempo è passata a una \textit{major update},
 che ha modificato tutti i nomi dei metodi, e non viene aggiornata spesso.
  Ho scelto invece la seconda, \texttt{flutter\_nfc\_kit}, in quanto include un supporto maggiore da parte degli sviluppatori e sta crescendo rapidamente. 
\newline
Grazie alla documentazione fornita dagli sviluppatori è stato facile eseguire un prototipo che permetta la scansione dei documenti.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{../assets/PrototipoNFC.png} 
    \caption{Applicazione prototipale per dimostrare la fattibilità della scansione NFC}
\end{figure}

La libreria ci permette di recuperare i campi di ID, lo \textit{standard} ISO del \textit{chip} RFID (ad esempio la carta d’identità elettronica utilizza uno \textit{standard} ISO 14443), e gli \textit{historical bytes}. Questi ultimi rappresentano una piccola sezione dati fornita dal \textit{chip} che identificano in modo informativo il \textit{chip}, il produttore o la versione.
\newline 
\newline
Testando l’applicazione con una varietà di documenti e \textit{tag} NFC, ho riscontrato differenze significative nella struttura dei dati restituiti. Ad esempio, la tessera del \textit{tram} di Busitalia Veneto e quella di una palestra privata rispetto a documenti come la tessera sanitaria o il \textit{badge} universitario non forniscono né includono i campi relativi agli \textit{hystorical bytes}, evidenziando quindi come il comportamento e il livello di informazione dei \textit{tag} NFC vari sensibilmente in base allo \textit{standard} impiegato e al livello di sicurezza previsto dall’emittente.
\newline
Nel caso della CIE ho rilevato un comportamento peculiare: il campo identificativo (\texttt{id}) letto tramite NFC non rappresenta un identificatore univoco permanente, bensì un valore temporaneo che cambia a ogni scansione.
 Approfondendo la documentazione tecnica del \textit{chip} - disponibile sul sito del Ministero dell’Interno - emerge che la CIE adotta modelli di sicurezza avanzati, come il protocollo BAC\footnote{aggiungi} o il protocollo PACE\footnote{aggiungi}, che limitano severamente la quantità di informazioni accessibili senza autenticazione. In particolare il numero unico nazionale (\texttt{nun}) che si trova in alto a destra sul fronte del documento.
\newline
\newline
Infatti il \textit{chip} della Carta d’Identità Digitale (CIE) è progettato per memorizzare dati personali sensibili e proteggerli tramite una protocolli avanzati e non direttamente leggibili con una interrogazione NFC.
\newline
L’identificatore temporaneo e non persistente rientra nelle misure previste per ridurre i rischi legati al tracciamento e alla profilazione utente.
\newline
\newline
Questo rappresenta per il progetto un bel problema in quanto senza un identificativo del documento recuperabile tramite scansione è impossibile associare una singola chiave ad esso.
\subsubsection{Mitigazione del problema}
Per interagire con la Carta d’Identità Elettronica (CIE) è necessario utilizzare gli strumenti \textit{software} ufficiali messi a disposizione dall’Istituto Poligrafico e Zecca dello Stato (IPZS).
 Senza la loro implementazione, un’applicazione di terze parti può accedere solo a informazioni superficiali come quelle indicate precedentemente, senza accedere ai dati personali o ai \textit{file} protetti presenti sul documento.
\newline
\newline
Una prima soluzione valutata è stata quella di consultare la piattaforma dedicata agli sviluppatori che realizzano i software per la Pubblica Amministrazione (PA).
 Tra i progetti disponibili è presente anche il \textit{kit} di sviluppo ufficiale per Android, reperibile al \textit{repository}  \href{https://github.com/italia/cieid-android-sdk}{\texttt{cieid-android-sdk}}, che consente di integrare nei sistemi Android l’autenticazione basata su CIE. Tuttavia essendo sviluppato in Kotlin è compatibile esclusivamente per le applicazioni native Android ed entra in conflitto con uno dei punti fondamentali dello sviluppo di applicazioni in Flutter ovvero lo sviluppo multi-piattaforma.
\newline
\newline
A seguito di riunioni interne con il mio responsabile, si è scelto di non procedere su questa strada, sia per ragioni di tempo sia per evitare la gestione di dati sensibili, che sarebbero soggetti alle normative del GDPR\footnote{inserire} per l’azienda. Pertanto si è deciso di utilizzare come identificativo il valore degli \textit{historical bytes}, insieme allo standard del \textit{chip} NFC rilevato durante la scansione.
\newline
\newline
I documenti quali la CIE, la tessera sanitaria o le carte di credito adottano lo standard ISO/IEC 14443-4, che prevede la presenza di \textit{historical bytes}. Sebbene questi non rappresentino un identificatore univoco in senso assoluto, risulta estremamente improbabile che due \textit{tag} diversi registrino lo stesso valore, soprattutto se appartenenti a categorie differenti.
 Per ridurre ancora tale probabilità, l’applicazione esegue la verifica di unicità solo tra i documenti registrati dall’utente e non su tutti quelli presenti nel \textit{database} dell’applicazione, garantendo così un adeguato livello di affidabilità.


\begin{listing}[H]
  \caption{Funzione che permette la scansione del tag nfc}
  \begin{minted}[fontsize=\small]{dart}
Future<NFCTag?> fetchNfcData() async {
    try {
      if (defaultTargetPlatform == TargetPlatform.iOS) {
        await _nfcKitWrapper
          .setIosAlertMessage("Avvicina il dispositivo...");
      }
      NFCTag tag = await _nfcKitWrapper.poll();
      return tag;
    } catch (e) {
      await _nfcKitWrapper.finish();
      return null;
    }
}

Future<void> _scanNfcTag() async {
    if (_isScanning) return;
    setState(() => _isScanning = true);
    try {
      final nfcService = context.read<INfcService>();
      dynamic tagData = 
        await nfcService.fetchNfcData();
      if (tagData != null && mounted) {
        setState(() {
          hBytes = tagData.historicalBytes 
            ?.toString() ?? 'N/D';
          standard = tagData.standard
            ?.toString() ?? 'N/D';
          if (hBytes.isNotEmpty && 
              hBytes != 'N/D' && 
              standard.isNotEmpty) {
            ScaffoldMessenger.of(context)
              .showSnackBar(const SnackBar(
                content: Text(
                  "Documento scansionato!"),
                backgroundColor: Colors.green));
          }
        });
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context)
          .showSnackBar(SnackBar(
            content: Text("Errore: $e"),
            backgroundColor: Colors.red));
      }
    } finally {
      if (mounted) {
        setState(() => _isScanning = false);
      }
    }
}
  \end{minted}
\end{listing}
\newpage

\subsection{Studio degli algoritmi di crittografia}
In questa sezione si espongono e si analizzano i principali algoritmi crittografici, evidenziandone il funzionamento e discutendo i rischi associati al loro impiego. Per molti esempi e descrizione degli scenari utilizzerò gli attori Alice e Bob che rappresentano due utenti generici che vogliono conversare tra di loro. 
\newline
\newline
Per analizzare la comunicazione digitale è importante considerare quattro aspetti:
\begin{enumerate}
  \item \textbf{Confidenzialità}: assicurare che nessun osservatore non autorizzato sia in grado di leggere il messaggio durante la trasmissione.
  \item \textbf{Integrità}: garantire che il messaggio non sia alterato da nessuno.
  \item \textbf{Autenticazione}: verificare che il mittente sia chi dichiara di essere.
  \item \textbf{Non ripudio}: impedire che il mittente possa negare di aver inviato il messaggio.
\end{enumerate}

\subsubsection{Algoritmi a chiave simmetrica}
Gli algoritmi di crittografia simmetrica utilizzano un’unica chiave segreta condivisa tra i due attori ed è usata sia per cifrare sia per decifrare il messaggio. 
\newline
Il funzionamento è descritto come segue:
\begin{enumerate}
  \item  Alice e Bob concordano o si scambiano in modo sicuro una chiave condivisa $k$;
  \item  Alice prende il messaggio in chiaro $P$ e applica un algoritmo di cifratura simmetrica $S$, ottenendo il messaggio cifrato $C$.
  \item  Quando Bob riceve $C$, applica l’algoritmo di decifratura $D$, utilizzando $k$, ricostruendo il messaggio originale $P$.
\end{enumerate}
Pertanto per adottare questo algoritmo Alice e Bob devono conoscere e adoperare la stessa chiave utilizzando un canale di comunicazione sicuro.
\begin{itemize}
  \item Se la chiave venisse rubata l’attaccante può fingersi il mittente originale.
  \item Non è possibile distribuire in modo sicuro la chiave privata a un partner remoto senza utilizzare un altro sistema di sicurezza.
\end{itemize}

\subsubsection{Algoritmi a chiave asimmetrica}

Gli algoritmi di crittografia asimmetrica superano le limitazioni logistiche degli algoritmi di crittografia simmetrici. Per ogni attore coinvolto nella comunicazione viene utilizzata una coppia di chiavi fondamentali per il processi di cifratura e decifratura.
\newline
Il funzionamento è descritto come segue.
\begin{enumerate}
  \item Bob genera una coppia di chiavi $(k^B_{pub} , K^B_{priv})$ e rende $k^B_{}$ pubblico a tutti;
  \item Alice ricerca la chiave pubblica di Bob e cifra il messaggio in chiaro $P$ con la chiave pubblica di Bob $k^B_{pub}$, ottenendo un messaggio cifrato $C$.
  \item Bob riceve il messaggio e lo decifra con utilizzando la propria chiave privata $k^B_{priv}$ ottenendo $P$.
\end{enumerate}
L’uso di questi algoritmi risolve il problema dello scambio della chiave presente negli algoritmi di crittografia simmetrica in quanto la condivisione della chiave pubblica sulla rete non compromette la sicurezza del sistema.
Inoltre si garantisce l’autenticazione e l’integrità dato che è possibile verificare l’identità del mittente invertendo il processo di crittografia.
  Il messaggio viene cifrato con la chiave privata del mittente e successivamente è possibile decifrarlo con la sua chiave pubblica corrispondente.
  Inoltre questo permette di verificare che il messaggio non sia stato alterato durante la comunicazione.

\subsection{Realizzazione di una \textit{chat end-to-end}}
Uno degli obbiettivi del progetto riguarda la generazione di coppie di chiavi pubbliche e private e il loro utilizzo per cifrare e decifrare i messaggi inseriti nell’applicazione.
Per soddisfare questo requisito, ho deciso di realizzare una \textit{chat end-to-end} che permetta lo scambio di messaggi tra 2 utenti della \textit{chat} mediante protocollo RSA (Rivest-Shamir-Adleman).
\subsubsection{Generazione sicura delle chiavi}
Il processo inizia con la creazione di un generatore di numeri pseudocasuali basata sul generatore \texttt{FortunaRandom}, messo a disposizione da \texttt{pointycastle}, per assicurare una adeguata fonte di entropia tale da garantire che il programma non generi coppie di chiavi con lo stesso valore numerico.
\newline

\begin{listing}[H]
  \caption{Generatore di numeri casuali}
  \begin{minted}{dart}
SecureRandom getSecureRandom() {
    final secureRandom = FortunaRandom(); 
    final seed = Uint8List(32);
    final random = Random.secure();
    for (int i = 0; i < seed.length; i++) {
      seed[i] = random.nextInt(256);
    }
    secureRandom.seed(KeyParameter(seed)); 
    return secureRandom;
  }
  \end{minted}
\end{listing}

Questo generatore viene passato al metodo \texttt{generateRSAkeyPair()} responsabile della creazione delle chiavi RSA. Il generatore produce quindi una coppia di chiavi lunga 256 \textit{byte}, che rappresenta la lunghezza standard delle moderne chiavi RSA.

\begin{listing}[H]
  \caption{Generazione della coppia di chiavi}
  \begin{minted}{dart}
AsymmetricKeyPair<PublicKey, PrivateKey> generateRSAkeyPair(SecureRandom secureRandom) {
    final keyGen = RSAKeyGenerator();
    keyGen.init(
      ParametersWithRandom(
        RSAKeyGeneratorParameters(BigInt.parse('65537'), 2048, 64),
        secureRandom,)
    );
    return keyGen.generateKeyPair();
}
  \end{minted}
\end{listing}

Per rispettare i requisiti e permettere allo \textit{stakeholder} di visualizzare il risultato ottenuto le chiavi sono mostrate in chiaro sull'applicazione, ma in un contesto pratico questo non deve avvenire in quanto compromette la sicurezza del sistema.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{../assets/KeyPairVisualized.png} 
    \caption{Risultato del processo di creazione delle chiavi}
\end{figure}

\subsubsection{Codifica e decodifica del messaggio}
Una volta generate le coppie di chiavi RSA è possibile utilizzarle per la realizzazione dei requisiti funzionali cinque e sei del progetto che riguardano la possibilità di cifrare e decifrare i messaggi inseriti nell’applicazione.
\newline
La cifratura è gestita dal metodo \texttt{rsaEncryptBase64()} che elabora il messaggio in chiaro tramite il motore crittografico \texttt{RSAEngine} sempre offerto dalla libreria \texttt{pointycastle} e dalla chiave pubblica del destinatario.

\begin{listing}[H]
  \caption{Codifica di un messaggio mediante l'uso delle chiave pubblica}
  \begin{minted}{dart}
    Future<String?> rsaEncryptBase64(String plainText, RSAPublicKey publicKey) async {
    final engine = RSAEngine(); 
    engine.init(true, PublicKeyParameter<RSAPublicKey>(publicKey));

    try {
      final encrypted = engine.process(Uint8List.fromList(utf8.encode(plainText)));
      return base64Encode(encrypted);
    } catch (e) {
      return null;
    }
  }
  \end{minted}
\end{listing}

Il messaggio cifrato restituito viene poi convertito in un formato \textit{Base64} in modo tale che sia memorizzato e trasmesso al \textit{database} in forma di stringa senza incorrere in problemi di formattazione. Come mostrato nell’immagine sottostante, il messaggio inserito risulta cifrato prima della memorizzazione.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../assets/Base64Decoder.png} 
    \caption{decodifica del testo cifrato in \textit{base64} -- Strumento: base64decode.org}
\end{figure}

La decifratura è affidata a \texttt{rsaDecryptBase64()}, che esegue l’operazione inversa decodificando il testo cifrato tramite l’uso della chiave privata del destinatario rendendo il testo di nuovo leggibile.

\begin{listing}[H]
  \caption{Decodifica di un messaggio mediante l'uso della chiave privata}
  \begin{minted}{dart}
  Future<String?> rsaDecryptBase64(String cipherText,RSAPrivateKey privateKey) async {
    final engine = RSAEngine();
    engine.init(false, PrivateKeyParameter<RSAPrivateKey>(privateKey));

    try {
      final decrypted = engine.process(base64Decode(cipherText));
      return utf8.decode(decrypted);
    } catch (e) {
      return "Messaggio non decodificabile";
    }
  }
  \end{minted}
\end{listing}

\subsubsection{Problema di questo algoritmo}
L’implementazione dell’algoritmo mostrato presenta un problema specifico per la realizzazione di una \textit{chat} tra due utenti.
 RSA consente la visione del messaggio in chiaro solo al destinatario (Bob) in quanto solo lui possiede la relativa chiave privata.
  Pertanto il mittente (Alice) dopo aver cifrato il testo con la chiave pubblica di Bob non ha più la possibilità di leggerlo. 
\newline
È possibile procedere in due modi diversi per la risoluzione del problema: 
\begin{itemize}
  \item la prima soluzione consiste nel salvare localmente sul dispositivo del mittente una copia del messaggio in chiaro prima che esso venga cifrato e inviato al database. In questo modo l’interfaccia utente mostra la versione salvata localmente per i messaggi che invia il mittente. 
\end{itemize}

\begin{itemize}
  \item la seconda soluzione adottata nel progetto consiste nell'invio di due copie dello stesso messaggio al \textit{database}: la prima cifrata con la chiave pubblica del destinatario e la seconda cifrata con la chiave pubblica del mittente. In questo modo entrambi gli interlocutori possono recuperare la loro versione decifrabile dal \textit{database} visualizzando i messaggi in chiaro.
\end{itemize}
Tuttavia questa scelta espone a un rischio aggiuntivo con: un attaccante potrebbe individuare nel \textit{database} due messaggi identici ma cifrati con chiavi differenti, mettendo il sistema a rischio. Per ridurre questa possibilità ho introdotto lo schema di \textit{padding} OAEP\footnote{Inserire} all’algoritmo RSA che introduce casualità e rende impossibile ottenere due testi cifrati uguali dallo stesso messaggio.

\begin{listing}[H]
  \caption{Modifica agli algoritmi di codifica e decodifica aggiungendo OAEP}
  \begin{minted}{dart}
  Future<String?> rsaEncryptBase64(String plainText, RSAPublicKey publicKey) async {
    final engine = OAEPEncoding(RSAEngine()); 
    engine.init(true, PublicKeyParameter<RSAPublicKey>(publicKey));
    // ...
  }

  Future<String?> rsaDecryptBase64(String cipherText,RSAPrivateKey privateKey) async {
    final engine = OAEPEncoding(RSAEngine());
    engine.init(false, PrivateKeyParameter<RSAPrivateKey>(privateKey));
    // ...
  }
  \end{minted}
\end{listing}


\subsection{Gestione sicura delle chiavi pubbliche e private}
La protezione delle chiavi crittografiche generate sul dispositivo dell’utente costituisce uno dei punti più delicati del progetto. L’applicazione pertanto è stata progettata per garantire il principio di controllo totale da parte dell’utente sulla chiave privata.
\subsubsection{Separazione e archiviazione delle chiavi}
Durante la creazione di un nuovo \textit{wallet}, l’applicazione chiama la classe \texttt{WalletService} ed esegue la creazione del nuovo \textit{wallet} generando una coppia di chiavi RSA chiamando la classe \texttt{CriptoUtils}, come scritto precedentemente. 
\begin{listing}[H]
  \caption{Generazione coppia di chiavi private in \texttt{wallet\_service.dart}}
  \begin{minted}{dart}
final keyPair = cryptoUtils.generateRSAkeyPair(cryptoUtils.getSecureRandom());
final publicKeyObj = keyPair.publicKey as pointy.RSAPublicKey;
final privateKeyObj = keyPair.privateKey as pointy.RSAPrivateKey;
  \end{minted}
\end{listing}

A questo punto avviene le separazione delle due chiavi, tenendo presente che la chiave privata deve essere salvata localmente sul dispositivo mentre quella pubblica deve essere trasferita insieme alle caratteristiche del \textit{wallet} sul database. 
\newline \newline
// Inserire Immagine
\newline \newline
La chiave pubblica viene inviata al \textit{database} Firestore per essere associata al \textit{wallet} dell’utente insieme ai dati di creazione quali userID, \textit{email}, nome del \textit{wallet}, i dati di scansione \textit{historical bytes} e \textit{standard}.
  Quindi è resa disponibile sul \textit{database} per le operazioni di comunicazione.
\begin{listing}[H]
  \caption{Invio delle informazioni pubbliche del \textit{wallet} su Firebase}
  \begin{minted}{dart}
Map<String, dynamic> walletDataForFirestore = {
  'userId': userId,
  'email': email,
  'name': tempWallet.name,
  'hBytes': hBytes,
  'standard': standard,
  'color': colorString,
  'publicKey': tempWallet.publicKey,
  'createdAt': FieldValue.serverTimestamp(),
};

DocumentReference docRef = await _firestore.collection('wallets')
                                  .add(walletDataForFirestore);
  \end{minted}
\end{listing}

Invece, per la chiave privata viene chiamata la classe di \texttt{SecureStorage} che utilizza la libreria di \texttt{flutter\_secure\_storage} per utilizzare il \textit{Keychain} sui dispositivi iOS o il \textit{KeyStore} per i dispositivi Android, proteggendo la chiave tramite crittografia a sistema operativo.
 La chiave è conservata solo per il tempo necessario al salvataggio locale sul dispositivo. Dopo l’operazione di scrittura il valore della chiave privata viene impostata su valore nullo assicurando che nessuna copia venga inutilmente salvata nella memoria temporanea del dispositivo.

\begin{listing}[H]
  \caption{Salvataggio della chiave privata sul dispositivo}
  \begin{minted}{dart}
await _secureStorage.writeSecureData(tempWallet.localKeyIdentifier,
                     tempWallet.transientRawPrivateKey!);
tempWallet.transientRawPrivateKey = null;
  \end{minted}
\end{listing}


\subsubsection{La classe \texttt{SecureStorage}}
La classe \texttt{SecureStorage} è responsabile del salvataggio, lettura ed eliminazione della chiave privata sul dispositivo locale.
 Possiamo immaginare il funzionamento di \texttt{SecureStorage} come una mappa o un dizionario chiave valore, in grado di garantire che la chiave venga protetta in modo robusto.

\begin{listing}[H]
  \caption{La classe \texttt{SecureStorage}}
  \begin{minted}{dart}

class SecureStorage implements ISecureStorage {
  final FlutterSecureStorage storage;

  SecureStorage({FlutterSecureStorage? storage}) : storage = storage 
                                    ?? const FlutterSecureStorage();

  @override
  Future<void> writeSecureData(String key, String value) async {
    await storage.write(key: key, value: value);
  }

  @override
  Future<String?> readSecureData(String key) async {
    final value = await storage.read(key: key);
    return value;
  }

  @override
  Future<void> deleteSecureData(String key) async {
    await storage.delete(key: key);
  }
}
  \end{minted}
\end{listing}

Per accedere al dato salvato localmente è quindi necessario che alla creazione della coppia di chiavi venga anche generata una terza chiave identificativa più piccola che permetta il recupero della chiave privata dal KeyStore o dal Keychain

\begin{listing}[H]
  \caption{Creazione della chiave identificativa}
  \begin{minted}{dart}
var uuid = const Uuid();
final newLocalKeyIdentifier = uuid.v4();
  \end{minted}
\end{listing}

Tramite il pacchetto \texttt{uuid} è possibile generare una chiave unica da associare alla chiave privata per permetterne il recupero. È importante sottolineare come questa chiave-identificatore possa essere memorizzata sul \textit{database} in quanto non compromette la sicurezza del sistema.

\subsubsection{Procedura di recupero chiave}
Questa architettura delega all’utente la responsabilità esclusiva sulla propria chiave privata, in quanto non esiste alcun modo per rigenerarla partendo dai dati memorizzati nel \textit{database}.
In caso di smarrimento o trasferimento da un dispositivo a un altro l’applicazione permette una procedura di recupero. Tuttavia questo richiede che l’utente esporti manualmente la chiave. 
Per ragioni di tempo, al momento l'applicazione permette il recupero solo tramite inserimento di testo. Tuttavia, la progettazione è stata eseguita considerando la possibilità di implementare un metodo alternativo di salvataggio della chiave privata su un \textit{tag} NFC singolo in modo tale che l’utente possa salvare in un dispositivo esterno allo \textit{smartphone}


\section{Risultati Raggiunti}

L’applicazione progettata e sviluppata durante il percorso di \textit{stage} implementa tutte le principali funzionalità previste dai requisiti funzionali, oltre ad alcune aggiuntive volte a migliorare l’esperienza utente.  
Il prodotto finale consente la gestione sicura di chiavi crittografiche asimmetriche, l’associazione di documenti mediante tecnologia NFC e l’invio e ricezione di messaggi cifrati tramite un sistema di \textit{chat end-to-end}.

\subsubsection*{Funzionalità Implementate}
\begin{itemize}
    \item \textbf{Accesso e registrazione}: l’utente può creare un account e accedere all’applicazione tramite l'inserimento di \textit{email} e \textit{password}. Il sistema di autenticazione sfrutta un \textit{database} remoto per la gestione degli utenti.
    \item \textbf{Creazione ed eliminazione del \textit{wallet}}: un utente può generare la propria coppia di chiavi crittografiche e, se necessario, eliminarle sia dal \textit{database} locale sia da quello remoto.
    \item \textbf{Rimozione della chiave privata dal dispositivo}: è stata introdotta la possibilità di rimuovere la chiave privata dal dispositivo, permettendone il salvataggio in uno spazio alternativo esterno al \textit{Keystore/Keychain}.
    \item \textbf{Recupero del \textit{wallet}}: l’utente può ripristinare il proprio \textit{wallet} in caso di smarrimento del dispositivo o migrazione verso uno nuovo, tramite reinserimento della chiave privata precedentemente esportata.
    \item \textbf{\textit{Chat end-to-end}}: l’applicazione mette a disposizione un servizio di messaggistica sicura basato su chiavi crittografiche RSA.
    \item \textbf{Ricerca tramite \textit{email}}: l’utente può individuare un altro utente tramite ricerca per indirizzo \textit{email} e avviare con esso una conversazione sicura.
    \item \textbf{Ricerca tramite scansione NFC}: attraverso scansione NFC di un documento fisico, l’applicazione può identificare automaticamente l’utente associato e avviare una nuova interazione.
\end{itemize}

\subsection{Risultati Quantitativi}

Per valutare in maniera oggettiva la portata del progetto, è stata condotta un’analisi quantitativa del codice prodotto.  
L’intero lavoro di sviluppo ha portato alla realizzazione di una base di codice strutturata come riportato nella tabella seguente:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        \textbf{Metrica} & \textbf{Valore} \\
        \hline
        Numero di \textit{file} sorgenti & 95 \\
        \hline
        Righe di codice & 12916 \\
        \hline
        Righe di commento & 800 \\
        \hline
    \end{tabular}
    \caption{Dati relativi all'implementazione}
\end{table}

La quantità significativa sia del numero di \textit{file} sia delle linee di codice effettive
 è principalmente dovuta alla separazione modulare dei \textit{widget} utilizzati per la progettazione delle schermate.
  Il \textit{framework} inoltre tende ad essere particolarmente verboso: anche un singolo \textit{file} può facilmente superare le 150 righe di codice, soprattutto quando si pensa allo sviluppo multipiattaforma e si producono diversi \textit{dialog} scelti per i vari sistemi operativi.

\subsection{Risultati Qualitativi}

All’inizio dello sviluppo sono stati definiti i requisiti di qualità che il sistema finale avrebbe dovuto rispettare.  
I risultati sono stati verificati attraverso lo sviluppo di \textit{test} automatici e dal raggiungimento della copertura del codice. 

\begin{itemize}
  \item \textbf{Il requisito RQ1} mirava a garantire l'affidabilità di generazione e coerenza delle chiavi con una soglia minima del $95\%$. Per la verifica è stato sviluppato un test di unità che attraverso 100 cicli di generazione e modifica ha verificato la corretta associazione tra chiave pubblica e privata, e la loro unicità delle coppie sfruttando l'elevata entropia del generatore \texttt{FortunaRandom}.
  \item \textbf{Il requisito RQ2} stabiliva una soglia di generazione massima di 2 secondi per l'operazione di un nuovo \textit{wallet} che include la generazione della coppia RSA. Per verificare questo è stato implementato un test di integrazione che cronometrasse l'esecuzione della funzione \texttt{Wallet.generateNew}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../assets/testFunzionele.png} 
    \caption{Misurazione per RQ2}
\end{figure}

\begin{itemize}
  \item \textbf{Il requisito RQ3} imponeva il raggiungimento di una copertura di \textit{test} automatici del $70\%$. L'attività di \textit{test} ha coperto l'intera logica di \textit{frontend} e \textit{backend} con il raggiungimento di una copertura complessiva dell'$80\%$
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{../assets/testAutomatici.png} 
    \caption{Copertura del codice dei \textit{test} automatici}
\end{figure}

